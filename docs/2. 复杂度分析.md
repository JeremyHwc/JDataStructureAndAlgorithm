[toc]

# 复杂度分析

## 1、复杂度分析是什么

复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略的表示，越高阶复杂度的算法，执行效率越低。常见的复杂度如下图所示

![](imgs\complexity_summary.png)

## 2、为什么需要复杂度分析

### 2.1 测试结果非常依赖测试环境

测试环境中硬件的不同会对测试结果有很大的影响。比如，同一段代码，在i9处理器和i3处理器，运行时间差距就很大。

###  2.2 测试结果受数据规模的影响很大

对于小规模的数据排序，插入排序可能反倒会比快速排序要快。

## 3、复杂度分析怎么做

### 3.1 大O复杂度表示法

所有代码的执行时间T(n)与每行代码的执行次数成正比。
$$
T(n) = O(f(n))
$$
其中，T(n)表示代码执行的时间；

n表示数据规模的大小；

f(n)表示每行代码执行的次数总和。



大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**，所以也称为**渐进时间复杂度**（asymptotic time complexity），简称**时间复杂度**。



## 4、时间复杂度是什么

**时间复杂度全程渐进时间复杂度，表示算法的执行时间和数据规模之间的增长关系。**

时间复杂度是用来评估算法的执行效率的，可以用大O表示法进行表示，常见的时间复杂度包括O(1)、O(logn)/O(n)、O(nlogn)、O(n^2)等。为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念：**最好情况时间复杂度**、**最坏情况时间复杂度**和**平均情况时间复杂度**。很多时候，我们使用一个复杂度就可以满足需求。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。

### 4.1 代码示例

```java
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```



### 4.2 最好情况时间复杂度（best case time complexity）

最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。那么示例代码中的最好时间复杂度就是O(1)。

### 4.3 最坏情况时间复杂度（worst case time complexity）

最坏情况时间复杂度就是在最糟糕的情况下，执行这段代码的时间复杂度。那么示例代码的最坏时间复杂度就是O(n)。

### 4.4 平均情况时间复杂度（average case time complexity）

#### 4.4.1 是什么？

#### 4.4.2 为什么需要平均情况时间复杂度？

因为最好情况时间复杂度和最坏情况时间复杂度都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示代码平均情况下的复杂度，所以就需要引入**平均时间复杂度**的概念。

#### 4.4.3 怎么计算？

我们假设在数组中与不在数组中的概率都为1/2.另外，要查找的数据出现在0~n-1这n个位置的概率都是一样的，为1/n。所以根据概率乘法法则，要查找的数组出现在0~n-1中任意位置的概率就是1/(2n)

![](imgs/time_complexity_deduce.png)

这个值就是概率论中的**加权平均值**，也叫**期望值**，所以平均时间复杂度的全称应该叫**加权平均时间复杂度**或者**期望时间复杂度**。用大O表示法表示，时间复杂度就是O(n)。

### 4.5 均摊时间复杂度（amortized time complexity）

#### 4.5.1 代码示例

```java
 // array表示一个长度为n的数组
 // 代码中的array.length就等于n
 int[] array = new int[n];
 int count = 0;
 
 void insert(int val) {
    if (count == array.length) {
       int sum = 0;
       for (int i = 0; i < array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }

    array[count] = val;
    ++count;
 }
```

结合前文对最好时间复杂度、最差时间复杂度、以及平均时间复杂度的理解，可以看出上面这段代码的复杂度依次为O(1)、O(n)、O(1)，其中平均时间复杂度的计算依然是使用加权平均得到的。如下，

![](imgs/example_average_complexity.png)

#### 4.5.2 是什么

从上面的insert()函数来说，O(1)时间复杂度的插入和O(n)时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个O(n)插入之后，紧跟着n-1个O(1)的插入操作，循环往复。针对这种特殊的场景，我们引入了一种更加简单的分析方法：**摊还分析法**，通过摊还分析得到的时间复杂度称之为**均摊时间复杂度**。

#### 4.6.3 如何分析均摊时间复杂度

对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且，这些操作之间存在前后连贯的时序关系，我们可以将一组操作放在一块分析，看是否能够将较高时间复杂度那次操作的耗时，平均到其他哪些时间复杂度比较低的操作上。而且在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。

**均摊时间复杂度就是一种特殊的平均时间复杂度。**

### 4.6 练习题

```java
// 全局变量，大小为10的数组array，长度len，下标i。
int array[] = new int[10]; 
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i >= len) { // 数组空间不够了
     // 重新申请一个2倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来array数组中的数据依次copy到new_array
     for (int j = 0; j < len; ++j) {
       new_array[j] = array[j];
     }
     // new_array复制给array，array现在大小就是2倍len了
     array = new_array;
     len = 2 * len;
   }
   // 将element放到下标为i的位置，下标i加一
   array[i] = element;
   ++i;
}
```

最好时间复杂度：O(1)

最差时间复杂度：O(n)

平均时间复杂度：O(1)

均摊时间复杂度：O(1)



### 4.7 常见时间复杂度案例分析

![](imgs\common_time_complexity.png)

对于上图中罗列的复杂度量级，可以分为两类，**多项式量级**和**非多项式量级**。其中O(2^n)和O(n!)。

我们把时间复杂度为非多项式量级的算法问题叫做NP（Non-Deterministic Polynomial，非确定多项式）问题。当数据规模n越来越大时，非多项式量计算法的执行时间会几句增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。

#### 4.7.1 O(1)

一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是O(1)。

#### 4.7.2 O(logn)、O(nlogn)

```java
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
```

#### 4.7.3 O(m+n)、O(m*n)

```java
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

从代码中可以看出，m和n表示两个数据规模。我们无法事先评估m和n谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以上面这段代码的时间复杂度就是O(m+n)。针对这种情况，原来的加法法则就不正确了，

我们需要将加法法则改为：
$$
T1(m) + T2(n) = O(f(m) + g(n))
$$
乘法规则继续有效
$$
T1(m) * T2(n) = O(f(m) * f(n))
$$


## 5、 时间复杂度分析怎么做

### 5.1 只关注循环执行次数最多的一段代码

大O复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、地接、洗漱，只需要记录一个最大接的量级就可以。我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。

### 5.2 加法法则：总复杂度等于量级最大的那段代码的复杂度

$$
T1(n) = O(f(n)),T2(n) = O(g(n));

T(n) = T1(n) + T2(n) = max(O(f(n)),O(g(n))) = O(max(f(n),g(n)))
$$

### 5.3 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

$$
T1(n) = O(f(n)),T2(n) = O(g(n));T(n) = T1(n) + T2(n) = O(f(n)) * O(g(n)) = O(f(n)*g(n))
$$



## 6、空间复杂度是什么

空间复杂度全程就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。我们常见的空间复杂度是O(1)、O(n)、O(n^2)。如下这段代码的空间复杂度就是O(n.)

```java

void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```

